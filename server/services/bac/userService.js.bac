const slugify = require('slugify');
const asyncHandler = require('express-async-handler');
const User = require('../models/userModel');
const ApiError = require('../utils/apiError');
const jwt = require('jsonwebtoken');
const config = require('../config/jwtConfig');
const bcrypt = require('bcryptjs');
const { generateVerificationToken, sendVerificationEmail } = require('../utils/email');

// @desc    Get specific user by Email
// @route   post /api/v1/user/login
// @access  Public
exports.loginUser = asyncHandler(async (req, res, next) => {
  const { email, password } = req.body;

  // 1) Check if email and password exist
  if (!email || !password) {
    return next(new ApiError(`Please provide email and password`, 400));
  }

  const user = await User.findOne({ email }).select('+password');
  if (!user) {
    return next(new ApiError(`Incorrect email or password`, 401));
  }

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) {
    return next(new ApiError(`Incorrect email or password`, 401));
  }

  // 3) If everything ok, generate token
  const token = jwt.sign(
    { id: user._id, email: user.email, name: user.name },
    config.JWT_SECRET,
    { expiresIn: config.JWT_EXPIRES_IN }
  );

  // 4) Remove password from output
  user.password = undefined;

  // Cookie olarak gönder
  res.cookie('token', token, {
    httpOnly: true, // JS ile erişilemez
    secure: false, // HTTPS üzerinden gönder
    sameSite: 'lax', // CSRF koruması
    domain: process.env.COOKIE_DOMAIN, // Cookie'nin geçerli olduğu domain
    maxAge: config.JWT_COOKIE_EXPIRES * 24 * 60 * 60 * 1000 // 90 gün (ms cinsinden)
  });

  res.status(200).json({
    status: 'success',
    data: { user }
  });
});

// @desc    Create user
// @route   POST  /api/v1/user
// @access  Private
exports.registerUser = asyncHandler(async (req, res) => {
  const { name, email, password } = req.body;
  const hashedPassword = await bcrypt.hash(password, 10);

  const verificationToken = generateVerificationToken();
  const verificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 saat

  const user = await User.create({
    name,
    slug: slugify(name),
    email,
    password: hashedPassword,
    emailVerificationToken: verificationToken,
    emailVerificationExpires: verificationExpires
  });

  // Doğrulama emaili gönder
  await sendVerificationEmail(user.email, verificationToken);

  // Token oluştur ama email doğrulanana kadar kısıtlı erişim ver
  const token = jwt.sign(
    { id: user._id, email: user.email, name: user.name, isVerified: false },
    config.JWT_SECRET,
    { expiresIn: config.JWT_EXPIRES_IN }
  );

  res.cookie('token', token, {
    httpOnly: true,
    secure: false,
    sameSite: 'lax',
    domain: process.env.COOKIE_DOMAIN, // Cookie'nin geçerli olduğu domain
    maxAge: config.JWT_COOKIE_EXPIRES * 24 * 60 * 60 * 1000
  });

  res.status(201).json({
    status: 'success',
    message: 'Kayıt başarılı! Lütfen email adresinizi doğrulayın.',
    data: { user: { ...user._doc, password: undefined } }
  });
});


// Email doğrulama fonksiyonu
exports.verifyEmail = asyncHandler(async (req, res, next) => {
  const { token } = req.params;

  const user = await User.findOne({
    emailVerificationToken: token,
    emailVerificationExpires: { $gt: Date.now() }
  });

  if (!user) {
    return next(new ApiError('The verification token is invalid or expired', 400));
  }


  // if (user.isEmailVerified) {
  //   return next(new ApiError('This email address has already been verified', 400));
  // }


  user.isEmailVerified = true;
  user.emailVerificationToken = undefined;
  user.emailVerificationExpires = undefined;
  await user.save();

  // Yeni bir token oluştur (artık doğrulanmış)
  const newToken = jwt.sign(
    { id: user._id, email: user.email, name: user.name, isVerified: true },
    config.JWT_SECRET,
    { expiresIn: config.JWT_EXPIRES_IN }
  );

  res.cookie('token', newToken, {
    httpOnly: true,
    secure: false,
    sameSite: 'lax',
    domain: process.env.COOKIE_DOMAIN, // Cookie'nin geçerli olduğu domain
    maxAge: config.JWT_COOKIE_EXPIRES * 24 * 60 * 60 * 1000
  });

  res.status(200).json({
    status: 'success',
    message: 'Email adresiniz başarıyla doğrulandı!',
    data: { user: { ...user._doc, password: undefined } }
  });
});

// Doğrulama emailini yeniden gönderme
exports.resendVerificationEmail = asyncHandler(async (req, res, next) => {
  const { email } = req.body;

  const user = await User.findOne({ email });
  if (!user) {
    return next(new ApiError('Bu email adresine kayıtlı kullanıcı bulunamadı', 404));
  }

  if (user.isEmailVerified) {
    return next(new ApiError('This email address has already been verified', 400));
  }

  const verificationToken = generateVerificationToken();
  const verificationExpires = Date.now() + 24 * 60 * 60 * 1000;

  user.emailVerificationToken = verificationToken;
  user.emailVerificationExpires = verificationExpires;
  await user.save();

  await sendVerificationEmail(user.email, verificationToken);

  res.status(200).json({
    status: 'success',
    message: 'Doğrulama emaili yeniden gönderildi'
  });
});


// @desc    Get user profile
// @route   GET /api/v1/user/profile
// @access  Private
exports.getUserProfile = asyncHandler(async (req, res, next) => {
  const user = await User.findById(req.user.id);

  if (!user) {
    return next(new ApiError('User not found', 404));
  }

  res.status(200).json({
    status: 'success',
    data: {
      user
    }
  });
});


exports.logoutUser = asyncHandler(async (req, res) => {
  res.clearCookie('token');
  res.status(200).json({
    status: 'success',
    message: 'Logged out successfully'
  });
});




exports.updateUserProfile = asyncHandler(async (req, res, next) => {
  // 1) Kullanıcıyı bul ve güncelle
  const updatedUser = await User.findByIdAndUpdate(
    req.user.id,
    {
      name: req.body.name,
      email: req.body.email,
      slug: slugify(req.body.name)
    },
    {
      new: true, // Güncellenmiş dokümanı döndür
      runValidators: true // Model validasyonlarını çalıştır
    }
  ).select('-password'); // Şifreyi döndürme

  // 2) Eğer email değiştiyse, doğrulama durumunu sıfırla
  if (req.body.email !== req.user.email) {
    updatedUser.isEmailVerified = false;
    const verificationToken = generateVerificationToken();
    updatedUser.emailVerificationToken = verificationToken;
    updatedUser.emailVerificationExpires = Date.now() + 24 * 60 * 60 * 1000; // 24 saat
    await updatedUser.save();

    // Yeni doğrulama emaili gönder
    await sendVerificationEmail(updatedUser.email, verificationToken);
  }

  // 3) Yeni token oluştur (isim değişikliği için)
  const token = jwt.sign(
    { id: updatedUser._id, email: updatedUser.email, name: updatedUser.name },
    config.JWT_SECRET,
    { expiresIn: config.JWT_EXPIRES_IN }
  );

  // 4) Cookie'yi güncelle
  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    domain: process.env.COOKIE_DOMAIN, // Cookie'nin geçerli olduğu domain
    maxAge: config.JWT_COOKIE_EXPIRES * 24 * 60 * 60 * 1000
  });

  res.status(200).json({
    status: 'success',
    data: {
      user: updatedUser
    }
  });
});

exports.checkAuth = asyncHandler(async (req, res) => {
  // Middleware geçtiyse kullanıcı authenticated demektir
  res.status(200).json({
    status: 'success',
    data: {
      user: req.user // decoded JWT payload
    }
  });
});

//
// // @desc    Get list of user
// // @route   GET /api/v1/user
// // @access  Public
// exports.getUsers = asyncHandler(async (req, res) => {
//   const page = req.query.page * 1 || 1;
//   const limit = req.query.limit * 1 || 5;
//   const skip = (page - 1) * limit;
//
//   const user = await User.find({}).skip(skip).limit(limit);
//   res.status(200).json({ results: user.length, page, data: user });
// });

// // @desc    Update specific user
// // @route   PUT /api/v1/user/:id
// // @access  Private
// exports.updateUser = asyncHandler(async (req, res, next) => {
//   const { id } = req.params;
//   const { name } = req.body;
//
//   const user = await User.findOneAndUpdate(
//     { _id: id },
//     { name, slug: slugify(name) },
//     { new: true }
//   );
//
//   if (!user) {
//     res.status(404).json({ msg: `No user for this id ${id}` });
//     // return next(new ApiError(`No user for this id ${id}`, 404));
//   }
//   res.status(200).json({ data: user });
// });
//
// // @desc    Delete specific user
// // @route   DELETE /api/v1/user/:id
// // @access  Private
// exports.deleteUser = asyncHandler(async (req, res, next) => {
//   const { id } = req.params;
//   const user = await User.findByIdAndDelete(id);
//
//   if (!user) {
//     res.status(404).json({ msg: `No user for this id ${id}` });
//     // return next(new ApiError(`No user for this id ${id}`, 404));
//   }
//   res.status(204).send();
// });

